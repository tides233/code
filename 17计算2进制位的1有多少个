#include<stdio.h>
//完善的法一
/*此处可计算正整数的2进制位中1的个数，但如果是负数的话，则无效*/
//若想完善，可以将n转化成无符号整形
                                                       //传参传的是2进制补码？
//如：
//int trans(unsigned int n)
//{
//	int count = 0;
//	while (n)
//	{
//		if (n % 2 == 1)
//		{
//			count++;
//		}
//		n = n / 2;
//
//	}
//	return count;
//}
//---------------------------------------------------------------

//法二
//但是当我们被要求不能使用无符号整型时该如何处理？
//联想到一个数字按位与1后，就能  得到  其2进制位的最后一位，
//那么只要让该数字  向右移1位  再与1按位与，那么就能得到每一位的值
// 当得到1时就让计数器++
//eg：
//10   ->  0000 101  0
//                   ↓
//15&1 ->  0000 000  0
//                  
//15>1 ->  0000 010  1
//                   ↓ 
//再&1 ->  0000 000  1
//
//再>1 ->  0000 001  0
//                   ↓
//再&1 ->  0000 000  0
//
//再>1 ->  0000 000  1
//                   ↓
//再&1 ->  0000 000  1

//int trans(int n)
//{
//	int count = 0;
//	int i = 0;
//	for (i = 0; i < 64; i++)/*此处64表示64位平台，如果是32位就小于32*/
//	{
//		if ((n>>1)&1==1)
//		{
//			count++;
//		}
//	}
//	return count;
//}
//---------------------------------------------------------------------
int trans(int n)/*不完善的法一*/
{
	int count = 0;
	while (n)
	{
		if (n%2==1)
		{
			count++;
		}
		n = n / 2;

	}
	return count;
}
int main()
{
	int n = 0,ret=0;
	scanf("%d", &n);
	ret = trans(n);
	printf("%d", ret);
	return 0;
}
